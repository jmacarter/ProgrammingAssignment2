install.packages(c("boot", "class", "cluster", "codetools", "foreign", "KernSmooth", "lattice", "MASS", "Matrix", "nlme", "nnet", "rpart", "spatial", "survival"))
mydata<-rnorm(100)
sd(mydata)
sd(na.rm=FALSE, mydata)
args(lm)
lm(data=mydata, y~x, model=FALSE, 1:1000)
lm(data=mydata, y~x, model=FALSE, 1:100)
lm(y ~ x, mydata, 1:100, model = FALSE)
lm
make.power <- function(n) {}
make.power <- function (n) {
pow <- function(x){
x^n
}
}
make.power <- function (n) {
pow <- function(x){
x^n
}
}
cube <- make.power(3)
cube(3)
square<-make.power(2)
square(3)
cube(2)
ls(environment(cube))
gen("n", environment(cube))
get("n", environment(cube))
y<- 10
f<-function(x) {}
make.power <- function (n) {
g <- function(x) {
x*y
}
f(3)
g <- function(x) {
x*y
}
f(3)
y<- 10
f(3)
source('~/.active-rstudio-document')
library(datasets)
data(iris)
?iris
colmeans(Sepal.Length)
x <- colmeans(Sepal.Length)
x <- colMeans(iris)
apply(iris, 2, mean)
rowMeans(iris[, 1:4])
apply(iris, 1, mean)
apply(iris[, 1:4], 2, mean)
tapply(iris$Sepal.Length, iris$Species, mean)
library(datasets)
data(mtcars)
?mtcars
sapply(split(mtcars$mpg, mtcars$cyl), mean)
mean(mtcars[mtcars$cyl == "8",]$hp) - mean(mtcars[mtcars$cyl == "4",]$hp)
debug(ls)
## Jeff Carter
## jeffcarter@mac.com
## R Programming (July 25 2015)
## Assignment #2
## https://class.coursera.org/rprog-030/human_grading/view/courses/975104/assessments/3
## These functions cache and compute the inverse of a matrix.
## makeCacheMatrix: This function creates a special "matrix"
## object that can cache its inverse.
makeCacheMatrix <- function(mtx = matrix()) {
inverse <- NULL
set <- function(x) {
mtx <<- x;
inverse <<- NULL;
}
get <- function() return(mtx);
setinv <- function(inv) inverse <<- inv;
getinv <- function() return(inverse);
return(list(set = set, get = get, setinv = setinv, getinv = getinv))
}
## cacheSolve: This function computes the inverse of the special "matrix"
## returned by makeCacheMatrix above. If the inverse has already been calculated
## (and the matrix has not changed), then cacheSolve should retrieve the inverse
## from the cache.
cacheSolve <- function(mtx, ...) {
inverse <- mtx$getinv()
if(!is.null(inverse)) {
message("Getting cached data...")
return(inverse)
}
data <- mtx$get()
invserse <- solve(data, ...)
mtx$setinv(inverse)
return(inverse)
}
source('cachematrix.R')'
source("cachematrix.R")
setwd("/Volumes/SP PHD U3/Projects/R/R Programming/Assignment 1")
setwd("/Volumes/SP PHD U3/Git/ProgrammingAssignment2")
source("cachematrix.R")
B = matrix(
+   c(2, 4, 3, 1, 5, 7),
+   nrow=3,
+   ncol=2)
B <- matrix(
+   c(2, 4, 3, 1, 5, 7),
+   nrow=3,
+   ncol=2)
B <- matrix( c(2, 4, 3, 1, 5, 7), nrow=3, ncol=2)
makeCacheMatrix(mtx=B)
makeCacheMatrix(B)
data <- mtx$get()
mtx<-B
invserse <- solve(data, ...)
mtx <<- x;
source("cachematrix.R")
setinv <- function(inv) inverse <<- inv;
## Jeff Carter
## jeffcarter@mac.com
## R Programming (July 25 2015)
## Assignment #2
## https://class.coursera.org/rprog-030/human_grading/view/courses/975104/assessments/3
## These functions cache and compute the inverse of a matrix.
## makeCacheMatrix: This function creates a special "matrix"
## object that can cache its inverse.
makeCacheMatrix <- function(mtx = matrix()) {
inverse <- NULL
set <- function(x) {
mtx <<- x;
inverse <<- NULL;
}
get <- function() return(mtx);
setinv <- function(inv) inverse <<- inv;
getinv <- function() return(inverse);
return(list(set = set, get = get, setinv = setinv, getinv = getinv))
}
## cacheSolve: This function computes the inverse of the special "matrix"
## returned by makeCacheMatrix above. If the inverse has already been calculated
## (and the matrix has not changed), then cacheSolve should retrieve the inverse
## from the cache.
cacheSolve <- function(mtx, ...) {
inverse <- mtx$getinv()
if(!is.null(inverse)) {
message("Getting cached data...")
return(inverse)
}
data <- mtx$get()
inverse <- solve(data, ...)
mtx$setinv(inverse)
return(inverse)
}
cacheSolve <- function(mtx, ...) {
inverse <- mtx$getinv()
if(!is.null(inverse)) {
message("Getting cached data...")
return(inverse)
}
data <- mtx$get()
inverse <- solve(data, ...)
mtx$setinv(inverse)
return(inverse)
}
x<-B
getinv <- function() return(inverse);
setinv <- function(inv) inverse <<- inv;
